
# utility functions
_print() { printf "\e[1m$1\e[0m\n"; }
_error() { printf "\e[1;4merror\e[24m: $1\e[0m\n" >&2; exit 1; }
_ensure_line() {
    if [ ! -f $2 ]; then touch "$2"; fi
    grep -q -F "$1" "$2" || echo "$1" >> "$2"; }

# use_conda: Ensure that a Conda package manager is installed and enabled (stable)

# Syntax: use conda [<environment name>]
#    <environment name>: name of the environment (default: 'default')

# Notes:
#    - the Conda environment is populated with Python 2.x

use_conda() {
    ENV_NAME="${1:-default}"

    # ensure that conda is installed
    export CONDA_ROOT="${HOME}/.direnv/conda"
    if [[ ! -d ${CONDA_ROOT} ]]; then
        OS_NAME="$(uname)"; WORD_SIZE=$(getconf LONG_BIT)

        if [ "${OS_NAME}" == "Darwin" ]; then
            _print "conda: installing Conda package manager (64bit)"
            package_name="Miniconda2-latest-MacOSX-x86_64"
        elif [ "${OS_NAME}" == "Linux" ]; then
            if [ "${WORD_SIZE}" == "64" ]; then
                _print "conda: installing Conda package manager (64bit)"
                package_name="Miniconda2-latest-Linux-x86_64"
            else
                _print "conda: installing Conda package manager (32bit)"
                package_name="Miniconda2-latest-Linux-x86"
            fi
        else
            _error "unsupported platform: ${OS_NAME}"
        fi

        package="${TMPDIR:-/tmp}/miniconda.sh"
        wget "https://repo.continuum.io/miniconda/${package_name}.sh" -O ${package}
        bash ${package} -b -p ${CONDA_ROOT} && rm ${package}
    fi

    # add miniconda to the PATH
    path_add PATH "${CONDA_ROOT}/bin"
    if ! has conda; then
        _error "conda: 'conda' executable not found"; fi

    # ensure that this environment exists
    local ENV_PATH="${PWD}/.env/conda-${ENV_NAME}"
    if [[ ! -d ${ENV_PATH} ]]; then
        _print "conda: preparing Conda environment '${ENV_NAME}'"
        conda create --prefix "${ENV_PATH}" --quiet python > /dev/null
    fi

    # activate this environment
    source activate "${ENV_PATH}"
}

# use_julia: Ensure that a Julia environment is installed and enabled (alpha)

# Syntax: use julia <julia version> [<environment name>]
#    <julia version>: version of the Julia compiler
#    <environment name>: environment name (default: 'default')

# Notes:
#    - powered by Playground.jl, see https://github.com/Rory-Finnegan/Playground.jl

use_julia() {
    if [[ $# -lt 1 ]]; then
        _error "invalid syntax: should be 'use julia <julia version>'"
    fi

    ENV_NAME="${2:-default}"

    # ensure that playground is installed
    local PLAYGROUND_ROOT="${HOME}/.direnv/playground"
    if [[ ! -d ${PLAYGROUND_ROOT} ]]; then
        _print "julia: installing Playground.jl"
        OS_NAME="$(uname)"

        if [ "${OS_NAME}" == "Darwin" ]; then
            package_name="v0.0.6_pre-alpha/playground-osx.tar.gz"
        elif [ "${OS_NAME}" == "Linux" ]; then
            package_name="v0.0.6_pre-alpha/playground-linux.tar.gz"
        else
            _error "unsupported platform: ${OS_NAME}"
        fi

        package="${TMPDIR:-/tmp}/playground.tar.gz"
        wget "https://github.com/Rory-Finnegan/Playground.jl/releases/download/${package_name}" -O ${package}
        tar xzf ${package} && rm ${package}
        echo $(dirname ${package})
        mv $(dirname ${package})/playground "${HOME}/.direnv/"
        ln -s "${HOME}/.playground" "${PLAYGROUND_ROOT}"
    fi

    # add playground to the PATH
    path_add LD_LIBRARY_PATH "${PLAYGROUND_ROOT}"
    path_add PATH "${PLAYGROUND_ROOT}"
    if ! has playground; then
        _error "julia: Playground.jl not found"; fi

    # ensure that this version of Julia compiler is installed
    if [[ ! -L ${PLAYGROUND_ROOT}/bin/julia-$1 ]]; then
        _print "julia: installing Julia compiler $1"
        playground install download $1
    fi

    # ensure that this environment exists
    local ENV_PATH="${PWD}/.env/playground-$1-${ENV_NAME}"
    if [[ ! -d ${ENV_PATH} ]]; then
        _print "julia: preparing Julia environment '${ENV_NAME}'"
        mkdir -p "${ENV_PATH}/bin"
        ln -s "${PLAYGROUND_ROOT}/bin/julia-$1" "${ENV_PATH}/bin/julia"
    fi

    # activate this environment
    export JULIA_PKGDIR="${ENV_PATH}/lib"
    export JULIA_HISTORY="${ENV_PATH}/history"
    path_add PATH "${ENV_PATH}/bin"

    if [[ ! -d ${JULIA_PKGDIR} ]]; then
        julia --eval "Pkg.init()"; fi
}

# use_jvm: Ensure that a JVM environment is installed and enabled (stable)

# Syntax: use jvm <package_name> [package_version]
#    package_name: name of the SDKMAN! package (required)
#    package_version: version of the SDKMAN! package (optional)

# Notes:
#    - powered by SDKMAN!, see http://sdkman.io/

use_sdkman() {
    # ensure that SDKMAN! is installed
    export SDKMAN_DIR="${HOME}/.direnv/sdkman"
    if [[ ! -d ${SDKMAN_DIR} ]]; then
        _print "jvm: installing SDKMAN!"
        curl -s "https://get.sdkman.io" | bash
    fi

    # add SDKMAN! to the PATH
    source "${SDKMAN_DIR}/bin/sdkman-init.sh"
    if ! has sdk; then
        _error "jvm: 'sdk' executable not found"
    fi
}

use_jvm() {
    if [[ $# -lt 1 ]]; then
        _error "invalid syntax: should be 'use jvm <package name> <package version>'"
    fi

    use sdkman

    # ensure that this JVM package is installed
    if [[ ! -d ${SDKMAN_DIR}/candidates/$1 ]]; then
        _print "jvm: installing JVM package $1"
        USE=n sdk install $1 $2
    fi

    # activate this package
    sdk use $1 $2
}

# use_perl: Ensure that a Perl environment is installed and enabled (stable)

# Syntax: use perl <perl version> [<environment name>]
#    <perl version>: version of the Perl interpreter
#    <environment name>: environment name (default: 'default')

# Notes:
#    - powered by Perlbrew, see http://perlbrew.pl/

use_perlbrew() {
    # ensure that Perlbrew is installed
    export PERLBREW_ROOT="${HOME}/.direnv/perlbrew"
    export PERLBREW_HOME="${PERLBREW_ROOT}"
    if [[ ! -d ${PERLBREW_ROOT} ]]; then
        _print "perl: installing Perlbrew"
        curl -L http://install.perlbrew.pl | bash
    fi

    # add Perlbrew to the PATH
    source "${PERLBREW_HOME}/etc/bashrc"
    if ! has perlbrew; then
        _error "perl: 'perlbrew' executable not found"; fi
}

use_perl() {
    if [[ $# -lt 1 ]]; then
        _error "invalid syntax; should be 'use perl <perl version>'"
    fi

    ENV_NAME="${2:-default}"

    use perlbrew

    # ensure that this version of Perl interpreter is installed
    if ! perlbrew use $1; then
        _print "perl: installing Perl interpreter $1"
        perlbrew install --notest $1
        perlbrew use $1
        perlbrew install-cpanm
    fi

    # ensure that this environment exists
    local ENV_PATH="${PWD}/.env/perlbrew-$1-${ENV_NAME}"
    if [[ ! -d ${ENV_PATH} ]]; then
        _print "perl: preparing Perl environment '${ENV_NAME}'"
        mkdir -p "${ENV_PATH}"
    fi

    # activate this environment
    export PERL_LOCAL_LIB_ROOT="${ENV_PATH}"
    export PERL5LIB="${PERL_LOCAL_LIB_ROOT}/lib/perl5"
    export PERL_MB_OPT="--install_base ${PERL_LOCAL_LIB_ROOT}"
    export PERL_MM_OPT="INSTALL_BASE=${PERL_LOCAL_LIB_ROOT}"
}

# use_python: Ensure that a Python environment is installed and enabled (stable)

# Syntax: use python <python version> [<environment name>]
#    <python version>: version of the Python interpreter
#    <environment name>: environment name (default: 'default')

# Notes:
#    - powered by Pyenv, see https://github.com/yyuu/pyenv

use_pyenv() {
    # ensure that Pyenv is installed
    export PYENV_ROOT="${HOME}/.direnv/pyenv"
    if [[ ! -d ${PYENV_ROOT} ]]; then
        _print "python: installing Pyenv"
        curl -L "https://raw.githubusercontent.com/yyuu/pyenv-installer/master/bin/pyenv-installer" | bash
    fi

    # add pyenv to the PATH
    path_add PATH "${PYENV_ROOT}/bin"
    if ! has pyenv; then
        _error "python: 'pyenv' executable not found"
    fi

    eval "$(pyenv init -)"
    export PYENV_VIRTUALENV_DISABLE_PROMPT=0
}

use_python() {
    if [[ $# -lt 1 ]]; then
        _error "invalid syntax: should be 'use python <python version>'"
    fi

    ENV_NAME="${2:-default}"

    use pyenv

    # ensure that this version of Python interpreter is installed
    if [[ ! -d ${PYENV_ROOT}/versions/$1 ]]; then
        _print "python: installing Python interpreter $1"
        pyenv install --skip-existing $1

        # upgrade pip, setuptools then install virtualenv
        pyenv shell $1
        pyenv exec pip install --upgrade --quiet setuptools
        pyenv exec pip install --upgrade --quiet --disable-pip-version-check pip
        pyenv exec pip install --upgrade --quiet virtualenv
        pyenv rehash
    else
        pyenv shell $1
    fi

    # ensure that this environment exists
    local ENV_PATH="${PWD}/.env/pyenv-$1-${ENV_NAME}"
    if [[ ! -d ${ENV_PATH} ]]; then
        _print "python: preparing Python environment '${ENV_NAME}'"
        virtualenv --always-copy "${ENV_PATH}"
    fi

    # activate this environment
    source "${ENV_PATH}/bin/activate"
}

# use_r: Ensure that a R environment is installed and enabled (stable)

# Syntax: use R [<environment name>]
#    <environment name>: environment name (default: 'default')

use_R() {
    ENV_NAME="${1:-default}"

    # check that R is installed
    if ! has R; then
        _error "R: 'R' executable not found"; fi

    if ! has Rscript; then
        _error "R: 'Rscript' executable not found"; fi

    local R_VERSION=$(Rscript -e "cat(paste(getRversion()))")
    local ENV_PATH="${PWD}/.env/R-${R_VERSION}-${ENV_NAME}"

    if [[ ! -d ${ENV_PATH} ]]; then
        _print "R: preparing R environment '${ENV_NAME}'"
        mkdir -p "${ENV_PATH}"
    fi

    export R_LIBS="${ENV_PATH}"
}

# use_rust: Ensure that a Rust environment is installed (beta)

# Syntax: use rust <rust version> [<environment name>]
#    <rust version>: version of the Rust compiler
#    <environment name>: environment name (default: 'default')

# Notes:
#    - powered by rsvm, see http://sdepold.github.io/rsvm/

use_rust() {
    if [[ $# -lt 1 ]]; then
        _error "invalid syntax: should be 'use rust <rust version>'"; fi

    ENV_NAME="${2:-default}"

    # ensure that rsvm is installed
    export RSVM_ROOT="${HOME}/.direnv/rsvm"
    if [[ ! -d ${RSVM_ROOT} ]]; then
        _print "rust: installing rsvm"

        if ! has git; then
            _error "git not found"; fi

        git clone git://github.com/sdepold/rsvm.git ${RSVM_ROOT}
    fi

    source "${RSVM_ROOT}/rsvm.sh"
    if ! has rsvm; then
        _error "rust: 'rsvm' executable not found"; fi

    # ensure this version of Rust compiler is installed
    if [[ ! -d ${RSVM_ROOT}/versions/$1 ]]; then
        _print "rust: installing Rust compiler $1"
        rsvm install $1
        rm -rf "${RSVM_ROOT}/current"
    fi

    local RUST_ROOT="${RSVM_ROOT}/versions/$1"
    path_add PATH "${RUST_ROOT}/dist/bin"
    path_add LD_LIBRARY_PATH "${RUST_ROOT}/dist/lib"
    path_add DYLD_LIBRARY_PATH "${RUST_ROOT}/dist/lib"
    path_add MANPATH "${RUST_ROOT}/dist/share/man"
    export RSVM_SRC_PATH="${RUST_ROOT}/src/rustc-source/src"
}
